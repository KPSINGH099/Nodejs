Check each case:
1ï¸âƒ£ Using fs.readFile (callback version)
fs.readFile(filePath, "utf8", (err, data) => { ... });

âœ” Asynchronous
âœ” Non-blocking

Node continues executing other code while reading the file.

2ï¸âƒ£ Using fs.promises.readFile (async/await)
const data = await fs.promises.readFile(filePath, "utf8");

âœ” Asynchronous
âœ” Non-blocking

Even with await, Node does not block the event loop.

3ï¸âƒ£ Using Synchronous version fs.readFileSync
const data = fs.readFileSync(filePath, "utf8");

âŒ Synchronous
âŒ Blocking

This blocks the entire event loop until the file is fully read.

ğŸ”¥ Clear Summary
Function	Blocking?	Non-blocking?
fs.readFile	âŒ	âœ”
fs.promises.readFile	âŒ	âœ”
fs.readFileSync	âœ”	âŒ
fs.writeFile	âŒ	âœ”
fs.promises.writeFile	âŒ	âœ”
fs.writeFileSync	âœ”	âŒ
fs.readdir	âŒ	âœ”
fs.readdirSync	âœ”	âŒ
ğŸ§  Best practice

ğŸ‘‰ Always use async (non-blocking) functions in production servers.
ğŸ‘‰ Use sync functions only in scripts or startup config.

If you want, I can also explain:

âœ… How Node.js handles async under the hood (event loop)
âœ… What is threadpool
âœ… How async still uses threads internally