Here are ALL major types of database relationships (1-1, 1-M, M-M, embedded, reference, polymorphic) explained with simple real-life examples, MongoDB/Mongoose perspective, and where they are used.

This is your complete reference.

ðŸ§© 1. One-to-One (1 : 1)

One document relates to exactly one other document.

âœ” Real-life examples:

User â†” Profile (Each user has exactly one profile)

Car â†” Registration

Person â†” Passport

Company â†” GST Registration

âœ” Mongoose Example:
const userSchema = new Schema({
  name: String,
  profile: { type: Schema.Types.ObjectId, ref: "Profile" }
});

âœ” When to use?

When two collections hold distinct but linked data

When profile grows large â†’ separate save space

ðŸ§© 2. One-to-Many (1 : M)

One document is linked to many documents.

âœ” Real-life examples:

Author â†” Books

User â†” Orders

Teacher â†” Students

Restaurant â†” Menu Items

Company â†” Employees

âœ” Mongoose Example:
author: {
  type: Schema.Types.ObjectId,
  ref: "Author"
}

âœ” When to use?

Most common scenario

Many children belong to one parent

ðŸ§© 3. Many-to-One (M : 1)

Same as one-to-many but seen from opposite direction.

Real-life examples:

Book belongs to exactly 1 Author

Order belongs to 1 User

This is the reverse side of 1:M

ðŸ§© 4. Many-to-Many (M : M)

Each document can relate to multiple documents on the other side.

âœ” Real-life examples:

Students â†” Courses
(A student takes many courses, each course has many students)

Products â†” Categories
(A product belongs to multiple categories)

Actors â†” Movies
(One actor in many movies; movie has many actors)

Developers â†” Projects

âœ” Mongoose Example:
const studentSchema = new Schema({
  name: String,
  courses: [{ type: Schema.Types.ObjectId, ref: "Course" }]
});

const courseSchema = new Schema({
  title: String,
  students: [{ type: Schema.Types.ObjectId, ref: "Student" }]
});

âœ” When to use?

Social media, e-commerce, education platforms

ðŸ§© 5. One-to-Many (Embedded Docs â€” NOT ref)

Child documents stored inside parent (not separate collection).

âœ” Real-life examples:

Order â†” Items

Blog â†” Comments

User â†” Addresses (multiple small subdocs)

âœ” Mongoose Example:
const orderSchema = new Schema({
  items: [
    {
      productId: String,
      qty: Number,
      price: Number
    }
  ]
});

âœ” When to use?

When child data is small & ALWAYS needed

Fast reads, fewer joins

Better performance than populate

ðŸ§© 6. One-to-One Embedded

Storing profile directly inside User

âœ” Real-life example:

User { profile: {...} }

âœ” Mongoose:
const userSchema = new Schema({
  name: String,
  profile: {
    age: Number,
    gender: String
  }
});

âœ” When to use?

If profile is always read together with user

No need for separate collection

ðŸ§© 7. Polymorphic Relationships (rare but important)

A record can reference different models dynamically.

âœ” Real-life examples:

Notification â†’ can be linked to

Post

Comment

User

Activity Log â†’ belongs to multiple possible entities

Likes â†’ user can like post, comment, photo, reel

âœ” Mongoose Example:
const likeSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User" },
  likeableId: Schema.Types.ObjectId,
  likeableType: String  // "Post" | "Comment" | "Photo"
});

âœ” When to use?

Social media apps

Audit logs

Tracking activity on different models

ðŸ§© 8. Self-Referential Relation

Document relates to same model.

âœ” Real-life examples:

Employee â†” Manager (one employeeâ€™s manager is another employee)

Comment â†” Parent Comment (nested comments)

Category â†” Subcategories

âœ” Mongoose Example:
const employeeSchema = new Schema({
  name: String,
  manager: { type: Schema.Types.ObjectId, ref: "Employee" }
});

âœ” When to use?

Hierarchies

Trees

Threaded comments

Graph-like data

ðŸ§© 9. Many-to-Many With Additional Data (Join Table)

When relationship itself has extra properties.

âœ” Real-life examples:

Student â†” Course has â†’ grade, semester

User â†” Product (Wishlist) has â†’ addedAt

Employee â†” Project has â†’ role, hours, salary

âœ” Mongoose Example:
const enrollmentSchema = new Schema({
  student: { type: Schema.Types.ObjectId, ref: "Student" },
  course: { type: Schema.Types.ObjectId, ref: "Course" },
  grade: String,
  semester: String
});

âœ” When to use?

When relation has metadata

When simple M:M array is not enough

ðŸ§© 10. Virtual Populates (Reverse relations)

No foreign key stored in parent.
Mongoose computes relation via virtual field.

âœ” Real-life examples:

User â†’ Orders (orders store userId, but User doesn't store orders)

Author â†’ Books (books store authorId, author has no books[] array)

âœ” Example:
authorSchema.virtual("books", {
  ref: "Book",
  localField: "_id",
  foreignField: "author"
});

ðŸ§¨ FINAL SUMMARY TABLE
Relation Type	Example	Best Use
1:1	Userâ€“Profile	Split large data
1:M	Authorâ€“Books	Most common
M:1	Bookâ€“Author	Reverse side
M:M	Studentâ€“Courses	Social apps, e-commerce
1:M Embedded	Orderâ€“Items	Fast reads
1:1 Embedded	Userâ€“Settings	Always read together
Polymorphic	Like Post/Comment	Social apps
Self-Referential	Employeeâ€“Manager	Hierarchies
M:M with join	Studentâ€“Course(grade)	Extra metadata
Virtual populate	Reverse lookup	Clean schema

If you want, I can show:

âœ” Code examples of all relationships
âœ” Which relation is ideal for e-commerce, fintech, social media
âœ” Full LLD design with all these relations integrated

Just tell me!